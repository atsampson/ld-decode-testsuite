#!/usr/bin/python3
# Compute and display the response of EFM filters for ld-decode.

import re

import numpy as np
import numpy.fft as npfft
import scipy.interpolate as spi
import scipy.signal as sps

from showfilter import Filter, show_filters

fs = 40e6

filters = []

def fir_filter_from_spec(spec, fir_size, fs, window='hamming'):
    """Generate coefficients for a FIR filter from a given specification:
    a 2D array of [frequency, amplitude, phase] rows, sorted in frequency
    order and with phase unwrapped. Intermediate points are interpolated.

    This works by using a large inverse FFT to generate an impulse response,
    which does not necessarily have a smooth response between the points in
    the frequency domain, then windowing the IR to the specified size, which
    smooths it out.

    See: Steven W. Smith, "The Scientist and Engineer's Guide to DSP", 2nd
    edition, chapter 17, p299. <https://dspguide.com/>"""

    # Get views of the columns in the spec
    spec_t = spec.transpose()
    freq_spec = spec_t[0]
    amp_spec = spec_t[1]
    phase_spec = spec_t[2]

    # Determine size of the FFT, making sure it's much bigger than the output
    real_size = 1024
    while real_size < (64 * fir_size):
        real_size *= 2
    complex_size = (real_size // 2) + 1

    # Frequency of each bin, up to the last frequency given in the spec
    freq_per_bin = (fs / 2) / complex_size
    nonzero_bins = min(int(freq_spec[-1] / freq_per_bin) + 1, complex_size)
    bin_freqs = np.arange(nonzero_bins) * freq_per_bin

    # Convert complex response spec to amplitude and unwrapped phase,
    # then interpolate to give amplitude/phase for each bin
    amp_interp = spi.interp1d(freq_spec, amp_spec, kind='cubic')
    phase_interp = spi.interp1d(freq_spec, phase_spec, kind='cubic')
    bin_amps = amp_interp(bin_freqs)
    bin_phases = phase_interp(bin_freqs)

    # Convert back into complex input data for the IFFT
    complex_data = np.zeros(complex_size, dtype=np.cdouble)
    complex_data[:nonzero_bins] = bin_amps * (np.cos(bin_phases) + 1.0j * np.sin(bin_phases))

    # Run the IFFT, giving a real result
    impulse = npfft.irfft(complex_data)

    # Rotate and window the result to get the FIR filter
    impulse[:] = np.roll(impulse, fir_size // 2)
    return impulse[:fir_size] * sps.get_window(window, fir_size)

spec = np.array([
    [0.0,     0.0,   0.0],
    [5.0e6,   0.0,   0.0],
    [10.0e6,  1.0,   0.0],
    [15.0e6,  0.0,   0.0],
    ])
b = fir_filter_from_spec(spec, 33, fs)
#filters.append(Filter('Test 1', b))

spec = np.array([
    [0.0,     0.0,   0.0],
    [5.0e6,   0.0,   0.0],
    [10.0e6,  1.0,   np.pi],
    [15.0e6,  0.0,   0.0],
    ])
b = fir_filter_from_spec(spec, 33, fs)
#filters.append(Filter('Test 2', b))

spec = np.array([
    np.linspace(0.0e6, 2.0e6, num=11),
    np.array([0.0, 0.2, 0.41, 0.73, 0.98, 1.03, 0.99, 0.81, 0.59, 0.42, 0.0]),
    np.array([0.0, -0.95, -1.05, -1.05, -1.2, -1.2, -1.2, -1.2, -1.2, -1.2, -1.2]) * -1.0,
    ]).transpose()
b = fir_filter_from_spec(spec, 2048, fs)
filters.append(Filter('Adam 2021', b))

spec = np.array([
    np.linspace(0.0e6, 1.9e6, num=11),
    np.array([0.0, 0.215, 0.41, 0.73, 0.98, 1.03, 0.99, 0.81, 0.59, 0.42, 0.0]),
    np.array([0.0, -0.92, -1.03, -1.11, -1.2, -1.2, -1.2, -1.2, -1.05, -0.95, -0.8]) * -1.25
    ]).transpose()
b = fir_filter_from_spec(spec, 2048, fs)
filters.append(Filter('Chad 2021-10-16', b))

def read_ngspice_spec(in_fn):
    """Read the output of an ngspice simulation as a filter spec.
    This assumes that your circuit's output is called 'out',
    and the input is always 1.0+0.0j."""

    spec = None
    num_rows = None

    with open(in_fn) as f:
        while True:
            line = f.readline()
            if line == "":
                break
            line = line.strip()

            # Read frequencies
            m = re.match(r'^<indep frequency (\d+)>$', line)
            if m is not None:
                # Add an extra row for 0 Hz
                num_rows = int(m.group(1)) + 1
                spec = np.zeros((num_rows, 3), dtype=np.double)

                # Assume the 0 Hz point has 0 amplitude
                # (This obviously won't be true for all filters!)
                spec[0][0:3] = 0.0

                for i in range(num_rows - 1):
                    line = f.readline().strip()
                    spec[i + 1][0] = float(line)

            # Read output
            if line == '<dep ac.v(out) frequency>':
                for i in range(num_rows - 1):
                    line = f.readline().strip()
                    m = re.match(r'^(.*)([+-])j(.*)$', line)

                    # Convert to amplitude/phase form
                    value = complex(float(m.group(1)),
                                    float(m.group(2) + m.group(3)))
                    spec[i + 1][1] = np.abs(value)
                    spec[i + 1][2] = np.angle(value)

    spec_t = spec.transpose()

    # Normalise the amplitudes
    spec_t[1] /= np.max(spec_t[1])

    # Unwrap the phases (for ease of interpolation later)
    spec_t[2] = np.unwrap(spec_t[2])

    return spec

def ngspice_to_python(specs, out_fn):
    """Write filter specs to a Python file.
    specs is [("name1", spec1), ("name2", spec2) ...]."""

    with open(out_fn, 'w') as f:
        f.write('# Generated by compute-efm-filter\n\n')
        f.write('import numpy as np\n\n')

        for name, spec in specs:
            f.write('%s = np.array([\n' % name)
            for row in spec:
                f.write('    [%s],\n' % (', '.join(str(v) for v in row)))
            f.write('    ], np.double)\n\n')

orig_ddd_spec = read_ngspice_spec('ddd-rf-filter.dat.ngspice')
orig_efm_spec = read_ngspice_spec('ldv4300d-efm-filter.dat.ngspice')

# XXX Trim spec to remove values that could be interpolated accurately

ngspice_to_python([
    ('ddd_spec', orig_ddd_spec),
    ('efm_spec', orig_efm_spec),
    ], 'efm_filter.py')

SIM_SIZE = 2048

b = fir_filter_from_spec(orig_ddd_spec, SIM_SIZE, fs)
filters.append(Filter('DDD frontend sim', b))

b = fir_filter_from_spec(orig_efm_spec, SIM_SIZE, fs)
filters.append(Filter('LD-V4300D EFM sim', b))

if False:
    from efm_filter import ddd_spec, efm_spec

    b = fir_filter_from_spec(ddd_spec, SIM_SIZE, fs)
    filters.append(Filter('DDD frontend saved', b))

    b = fir_filter_from_spec(efm_spec, SIM_SIZE, fs)
    filters.append(Filter('LD-V4300D EFM saved', b))

# The DDD frontend has an HPF (C401 and C402) then the LPF.
# The -3dB point is about 8 kHz.
# 100 nF * 0.5 kOhm; fc = 1/(100e-9 * 0.5e3 * 2 * pi) = 3183 - no
# With 200 ohm (the R in the op-amp's ground) it's 7957 which is spot on...
# So - zero at 0 Hz, pole at 8 kHz

def pole_zero_iir(pole_f, zero_f, fs):
    # Pre-warp for bilinear transform
    w1 = 2 * fs * np.tan(zero_f / (2 * fs))
    w2 = 2 * fs * np.tan(pole_f / (2 * fs))

    tf_b, tf_a = sps.zpk2tf([-w1], [-w2], 1.0)  # was w2/w1
    return sps.bilinear(tf_b, tf_a, fs)

# RC filter: R = 200R, C = 100nF (pole about 8 kHz in simulation)
b, a = pole_zero_iir(1 / (100e-9 * 200 * 2 * np.pi), 0, fs)
#filters.append(Filter('DDD HPF approx', b, a))
# We would want a filter that just inverted the phase of this.

# Further thought: there's no relevant information under 750 kHz or so anyway.
# So try a sharper HPF?

# The LD-V4300D has two filters, an elliptic(-ish) LPF then an HPF.
b, a = sps.ellip(N=3, rp=0.5, rs=37.0, Wn=1.8e6, fs=fs)
#filters.append(Filter('LD-V4300D EFM LPF', b, a))

show_filters(filters, fs=fs)
